@test
#test


"lang" describe

  "Total Symbols: " print! symbols size put!
  "  Total Sigils: " print! sigils size put!

  (debug? false ==) assert

  (2 'a define
    (3 a + (5 'a define a) -> +) -> a + 12 ==) assert

  (symbols "a" contains false ==) assert
  
  5 :five
  (symbols "five" contains) assert
  
  ~five
  (symbols "five" contains false  ==) assert

  (
    (
      (+) :myplus
    ) =mymath
  ) :defmod
  
  (defmod symbols "mymath" contains) assert

  (defmod #mymath 2 3 myplus 5 ==) assert

  ; Extend an existing scope
  (defmod 
    (#mymath 
     (-) :myminus) => .mymath 
    5 2 mymath %myminus 3 ==) assert

  (defmod mymath inspect ("myplus") ==) assert

  ((":mysigil" concat) ', sigil ,test "test:mysigil" ==) assert

  ("3 4 +" eval 7 ==) assert

  ("2 2 +" "tests/testload.min" fwrite @testload 4 ==) assert
  "tests/testload.min" rm

  (defmod 2 2 mymath %myplus 4 ==) assert
  
  (1 2 3 4 getstack (1 2 3 4) ==) assert

  ((1 2 3) setstack getstack (1 2 3) ==) assert

  ((1 2) (3 4) concat (1 2 3 4) ==) assert

  ((1 2 3) first 1 ==) assert
  
  ((1 2 3) rest (2 3) ==) assert

  (2 quote (2) ==) assert

  ((2 3) unquote getstack (2 3) ==) assert

  (4 (1 2 3) append (1 2 3 4) ==) assert

  (1 (2 3) cons (1 2 3) ==) assert

  ((1 2 3 4) 2 at 3 ==) assert
  ((1 2 3) size 3 ==) assert

  ((1 2 3 4) 5 contains false ==) assert
  ((1 2 3 4) 2 contains) assert

  ((1 2 3 4) (2 +) map (3 4 5 6) ==) assert

  (3 (succ) 3 times 6 ==) assert

  ((2 3 >) ("YES") ("NO") ifte "NO" ==) assert
  ((2 3 <) ("YES") ("NO") ifte "YES" ==) assert

  (0 :c
    (c 10 <) (c succ .c) while
    c 10 ==) assert

  ((1 2 3 4 5) (even?) filter (2 4) ==) assert

  (5 (dup 0 ==) (1 +) (dup 1 -) ( * ) linrec 120 ==) assert ;factorial of 5

  (
   (
    (pop) 
    (first) 
    ("Caught a " swap concat)
    ) try "Caught a MinEmptyStackError" ==) assert 

  (
   (
    (("TestError" "Test Message") raise) 
    (1 at)
    ) try "Test Message" ==) assert

  (
   (("test" (1 2) :)) try getstack ("test" (1 2)) ==) assert

  (
   (
    (() 1 at)
    (1)
    ) try 1 ==) assert

  ((a b +) (4 :a 5 :b) with 9 ==) assert

  ((4 :four 5 :five) ^myobject type "myobject" ==) assert

  ((4 :four 7 :seven) ^myobject2 'seven defines?) assert

  (("test" :test) =test1 test1 object?) assert

  (("test" :test) =test2 test2 module?) assert

  ("{\"a\": 1, \"b\": 2.3}" from-json ((a 1) (b 2.3)) ==) assert

  ((1 2 3 "aaa" 'q q true) to-json "[1,2,3,\"aaa\",\";sym:'q\",\";sym:q\",true]"  ==) assert

  ((1 2 3 "aaa" 'q q true) to-json from-json (1 2 3 "aaa" 'q q true)  ==) assert

  report
  ; Tidy up
  ~defmod
  clear
